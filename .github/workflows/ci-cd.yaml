name: CI-CD

# 觸發條件：任何分支 push 都會跑 build；只有 main 會跑 deploy
on:
  push: # 不指定 branches 表示匹配所有分支

jobs:
  # ============================================
  # Job 1: 建置與檢查（所有分支都會執行）
  # ============================================
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Install Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install Dependencies
        run: bun install

      - name: Setup Environment Files
        shell: bash
        run: |
          find . -type f -name ".env.example" -exec sh -c 'cp "$1" "${1%.*}"' _ {} \;

      - name: Run Linter
        run: bun lint

      - name: Build Application
        run: bun run build

  # ============================================
  # Job 2: 部署（僅 main 分支觸發；需 build 成功）
  # ============================================
  deploy:
    if: github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest

    env:
      SSH_USER: ${{ vars.VAR_SSH_USER }}
      SSH_PORT: ${{ vars.VAR_SSH_PORT }}
      SSH_HOST: ${{ secrets.SSH_HOST }}
      DEPLOY_SCRIPT_PATH: ./deploy.sh
      UPDATE_SCRIPT_PATH: ./update.sh

    steps:
      # --- 準備階段 ---
      - name: Checkout Repository
        uses: actions/checkout@v5

      - name: Install Required Tools
        shell: bash
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y expect

      # --- SSH 設定階段 ---
      - name: Setup SSH Directory
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

      - name: Write SSH Private Key
        shell: bash
        env:
          SSH_KEY_PASSPHRASE: ${{ secrets.SSH_KEY_PASSPHRASE }}
        run: |
          set -euo pipefail

          KEY_FILE=~/.ssh/id_deploy_enc
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"

          # 驗證文件是否成功創建
          if [ ! -f "$KEY_FILE" ]; then
            echo "Error: SSH key file was not created at $KEY_FILE"
            exit 1
          fi

          # 檢查文件大小（不應該為空）
          FILE_SIZE=$(stat -f%z "$KEY_FILE" 2>/dev/null || stat -c%s "$KEY_FILE" 2>/dev/null || echo "0")
          if [ "$FILE_SIZE" -eq 0 ]; then
            echo "Error: SSH key file is empty. Check if SSH_PRIVATE_KEY secret is set correctly."
            exit 1
          fi

          echo "SSH key file created successfully (size: $FILE_SIZE bytes)"

      - name: Add SSH Host to Known Hosts
        shell: bash
        run: |
          set -euo pipefail
          ssh-keyscan -p "${SSH_PORT}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>&1 || true
          chmod 644 ~/.ssh/known_hosts

      - name: Start SSH Agent
        shell: bash
        run: |
          set -euo pipefail
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=${SSH_AUTH_SOCK}" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=${SSH_AGENT_PID}" >> $GITHUB_ENV

      - name: Add SSH Key to Agent
        shell: bash
        env:
          SSH_KEY_PASSPHRASE: ${{ secrets.SSH_KEY_PASSPHRASE }}
        run: |
          set -euo pipefail

          KEY_FILE=~/.ssh/id_deploy_enc
          ABS_KEY_FILE=$(realpath "$KEY_FILE" || echo "$HOME/.ssh/id_deploy_enc")

          expect <<EXPECTEOF
            set timeout 10
            set passphrase "$SSH_KEY_PASSPHRASE"
            set key_file "$ABS_KEY_FILE"
            
            if {![file exists \$key_file]} {
              puts "Error: Key file does not exist: \$key_file"
              exit 1
            }
            
            spawn ssh-add "\$key_file"
            expect {
              "Enter passphrase" {
                send "\$passphrase\r"
                exp_continue
              }
              "Identity added" {
                puts "Key added successfully"
              }
              "Bad passphrase" {
                puts "Error: Bad passphrase"
                exit 1
              }
              "Could not open a connection" {
                puts "Error: Could not connect to ssh-agent"
                exit 1
              }
              "No such file or directory" {
                puts "Error: Key file not found: \$key_file"
                exit 1
              }
              timeout {
                puts "Error: Timeout waiting for passphrase prompt"
                exit 1
              }
              eof
            }
            catch wait result
            set exit_code [lindex \$result 3]
            if {\$exit_code != 0} {
              puts "Error: ssh-add exited with code \$exit_code"
              exit \$exit_code
            }
          EXPECTEOF

      - name: Verify SSH Key Loaded
        shell: bash
        run: |
          set -euo pipefail
          if ssh-add -l >/dev/null 2>&1; then
            echo "✓ SSH key successfully loaded into agent"
            ssh-add -l
          else
            echo "✗ No keys loaded in agent - authentication may fail"
            echo "This usually means the passphrase was incorrect or the key format is invalid"
            exit 1
          fi

      # --- 驗證階段 ---
      - name: Validate Deployment Scripts Exist
        shell: bash
        run: |
          set -euo pipefail
          [ -f "${DEPLOY_SCRIPT_PATH}" ] || { echo "deploy.sh not found at ${DEPLOY_SCRIPT_PATH}"; exit 1; }
          [ -f "${UPDATE_SCRIPT_PATH}" ] || { echo "update.sh not found at ${UPDATE_SCRIPT_PATH}"; exit 1; }

      # --- 部署階段 ---
      - name: Upload Scripts to Remote Server
        shell: bash
        run: |
          set -euo pipefail

          # 確保 ssh-agent 環境變數已設置
          export SSH_AUTH_SOCK="${SSH_AUTH_SOCK}"
          export SSH_AGENT_PID="${SSH_AGENT_PID}"

          # 驗證必要的環境變數
          [ -n "${SSH_PORT}" ] || { echo "Error: SSH_PORT is not set"; exit 1; }
          [ -n "${SSH_USER}" ] || { echo "Error: SSH_USER is not set"; exit 1; }
          [ -n "${SSH_HOST}" ] || { echo "Error: SSH_HOST is not set"; exit 1; }
          [ -n "${SSH_AUTH_SOCK}" ] || { echo "Error: SSH_AUTH_SOCK is not set"; exit 1; }

          # 驗證 SSH key 已載入
          ssh-add -l >/dev/null 2>&1 || { echo "Error: No SSH keys loaded in agent"; exit 1; }

          # 上傳到遠端暫存路徑，避免直接覆蓋舊檔造成中斷
          echo "Uploading scripts to remote server..."
          scp -P "${SSH_PORT}" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              "${DEPLOY_SCRIPT_PATH}" \
              "${SSH_USER}@${SSH_HOST}:/tmp/deploy.sh.new"

          scp -P "${SSH_PORT}" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              "${UPDATE_SCRIPT_PATH}" \
              "${SSH_USER}@${SSH_HOST}:/tmp/update.sh.new"

          # 設定執行權限
          ssh -p "${SSH_PORT}" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              "${SSH_USER}@${SSH_HOST}" \
              "chmod +x /tmp/deploy.sh.new /tmp/update.sh.new || true"

      - name: Execute Remote Deployment
        shell: bash
        run: |
          set -euo pipefail

          # 確保 ssh-agent 環境變數已設置
          export SSH_AUTH_SOCK="${SSH_AUTH_SOCK}"
          export SSH_AGENT_PID="${SSH_AGENT_PID}"

          # 驗證必要的環境變數
          [ -n "${SSH_PORT}" ] || { echo "Error: SSH_PORT is not set"; exit 1; }
          [ -n "${SSH_USER}" ] || { echo "Error: SSH_USER is not set"; exit 1; }
          [ -n "${SSH_HOST}" ] || { echo "Error: SSH_HOST is not set"; exit 1; }
          [ -n "${SSH_AUTH_SOCK}" ] || { echo "Error: SSH_AUTH_SOCK is not set"; exit 1; }

          # 驗證 SSH key 已載入
          ssh-add -l >/dev/null 2>&1 || { echo "Error: No SSH keys loaded in agent"; exit 1; }

          # 構建遠端部署腳本內容
          cat > /tmp/remote_deploy.sh <<'REMOTE_SCRIPT'
          #!/bin/bash
          set -euo pipefail

          # 首次部署：若遠端沒有 deploy.sh，執行完整部署
          if [ ! -f ~/deploy.sh ]; then
            echo 'No existing deploy.sh found. First-time deploy.'
            mv /tmp/deploy.sh.new ~/deploy.sh
            chmod +x ~/deploy.sh
            mv /tmp/update.sh.new ~/update.sh
            chmod +x ~/update.sh
            echo 'Running deploy.sh (first-time)...'
            ~/deploy.sh
            exit 0
          fi

          # 計算 checksum 以決定使用 deploy.sh 或 update.sh
          OLD_SUM=$(sha256sum ~/deploy.sh | awk '{print $1}')
          NEW_SUM=$(sha256sum /tmp/deploy.sh.new | awk '{print $1}')

          echo "Existing deploy.sh checksum: $OLD_SUM"
          echo "New deploy.sh checksum:      $NEW_SUM"

          # 無論如何，先把 update.sh 更新為新版
          mv /tmp/update.sh.new ~/update.sh
          chmod +x ~/update.sh

          if [ "$OLD_SUM" = "$NEW_SUM" ]; then
            echo 'deploy.sh unchanged. Running update.sh...'
            chmod +x ~/deploy.sh
            ~/update.sh
          else
            echo 'deploy.sh changed. Replacing and running deploy.sh...'
            mv /tmp/deploy.sh.new ~/deploy.sh
            chmod +x ~/deploy.sh
            ~/deploy.sh
          fi
          REMOTE_SCRIPT

          # 上傳遠端部署腳本並執行
          scp -P "${SSH_PORT}" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              /tmp/remote_deploy.sh \
              "${SSH_USER}@${SSH_HOST}:/tmp/remote_deploy.sh"

          # 執行遠端部署腳本
          ssh -p "${SSH_PORT}" \
              -o StrictHostKeyChecking=no \
              -o UserKnownHostsFile=~/.ssh/known_hosts \
              "${SSH_USER}@${SSH_HOST}" \
              "bash /tmp/remote_deploy.sh"
