name: CI-CD

# 觸發條件：任何分支 push 都會跑 build；只有 main 會跑 deploy
on:
  push: # 不指定 branches 表示匹配所有分支

jobs:
  # 1) 建置與檢查（所有分支都會執行）
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout # 取得程式碼
        uses: actions/checkout@v5 # https://github.com/actions/checkout

      - name: Install Bun # 安裝 Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install Package # 安裝套件
        run: bun install

      - name: Copy .env.example files # 尋找專案內所有名為 .env.example 的檔案，並複製成對應的 .env
        shell: bash
        run: find . -type f -name ".env.example" -exec sh -c 'cp "$1" "${1%.*}"' _ {} \;

      - name: Lint # 程式碼檢查（Lint）
        run: bun lint

      - name: 建置（Build）
        run: bun run build

  # 2) 部署（僅 main 分支觸發；需 build 成功）
  deploy:
    if: github.ref == 'refs/heads/main' # 只在 main 分支部署
    needs: build
    runs-on: ubuntu-latest

    env:
      SSH_USER: ${{ vars.VAR_SSH_USER }} # 例如 root
      SSH_PORT: ${{ vars.VAR_SSH_PORT }} # 例如 22
      SSH_HOST: ${{ secrets.SSH_HOST }} # IP/域名放在 Secrets
      DEPLOY_SCRIPT_PATH: ./deploy.sh # repo 內 deploy.sh 路徑（預設根目錄）
      UPDATE_SCRIPT_PATH: ./update.sh # repo 內 update.sh 路徑（預設根目錄）

    steps:
      - name: Checkout repo (to get deploy.sh and update.sh of this commit)
        uses: actions/checkout@v5

      - name: Prepare SSH key (with passphrase via agent)
        shell: bash
        env:
          SSH_KEY_PASSPHRASE: ${{ secrets.SSH_KEY_PASSPHRASE }}
        run: |
          set -euo pipefail

          echo "=== 開始準備 SSH key ==="

          echo "[步驟 1/6] 建立 .ssh 目錄..."
          mkdir -p ~/.ssh
          echo "✓ .ssh 目錄已建立"

          echo "[步驟 2/6] 寫入 SSH 私鑰檔案..."
          SSH_KEY_PATH="$HOME/.ssh/id_deploy_enc"
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          echo "✓ SSH 私鑰檔案已寫入: $SSH_KEY_PATH"

          echo "[步驟 3/6] 驗證檔案已建立..."
          if [ -f "$SSH_KEY_PATH" ]; then
            echo "✓ SSH key 檔案存在，大小: $(stat -f%z "$SSH_KEY_PATH" 2>/dev/null || stat -c%s "$SSH_KEY_PATH" 2>/dev/null || echo "unknown") bytes"
          else
            echo "✗ 錯誤: SSH key 檔案不存在"
            exit 1
          fi

          echo "[步驟 4/6] 啟動 SSH agent..."
          eval "$(ssh-agent -s)"
          echo "✓ SSH agent 已啟動，PID: $SSH_AGENT_PID"

          echo "[步驟 5/6] 安裝 expect..."
          sudo apt-get update -qq && sudo apt-get install -y -qq expect
          echo "✓ expect 已安裝"

          echo "[步驟 6/6] 使用 expect 載入 SSH key..."
          expect <<EOF
          set timeout 30
          spawn ssh-add "$SSH_KEY_PATH"
          expect {
            "Enter passphrase" {
              puts "收到 passphrase 提示，正在輸入..."
              send "$SSH_KEY_PASSPHRASE\r"
              exp_continue
            }
            "passphrase" {
              puts "收到 passphrase 提示，正在輸入..."
              send "$SSH_KEY_PASSPHRASE\r"
              exp_continue
            }
            "Identity added" {
              puts "✓ SSH key 已成功載入"
              expect eof
            }
            eof
          }
          catch wait result
          set exit_code [lindex \$result 3]
          puts "ssh-add 退出碼: \$exit_code"
          if {\$exit_code != 0} {
            puts "✗ 錯誤: ssh-add 失敗，退出碼: \$exit_code"
            exit \$exit_code
          }
          puts "✓ expect 腳本執行成功"
          exit 0
          EOF

          echo "[驗證] 檢查 SSH key 是否已載入..."
          if ssh-add -l; then
            echo "✓ SSH key 驗證成功，已載入的 key 列表："
            ssh-add -l
          else
            echo "✗ 錯誤: SSH key 驗證失敗，無法列出已載入的 key"
            exit 1
          fi

          echo "[最後步驟] 綁定 host 指紋..."
          ssh-keyscan -p "${SSH_PORT}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts
          echo "✓ Host 指紋已加入 known_hosts"

          echo "=== SSH key 準備完成 ==="

      - name: Validate local scripts exist
        shell: bash
        run: |
          set -euo pipefail
          [ -f "${DEPLOY_SCRIPT_PATH}" ] || { echo "deploy.sh not found at ${DEPLOY_SCRIPT_PATH}"; exit 1; }
          [ -f "${UPDATE_SCRIPT_PATH}" ] || { echo "update.sh not found at ${UPDATE_SCRIPT_PATH}"; exit 1; }

      - name: Upload scripts to remote (staging paths)
        shell: bash
        run: |
          set -euo pipefail
          # 上傳到遠端暫存路徑，避免直接覆蓋舊檔造成中斷
          scp -P "${SSH_PORT}" "${DEPLOY_SCRIPT_PATH}" "${SSH_USER}@${SSH_HOST}:/tmp/deploy.sh.new"
          scp -P "${SSH_PORT}" "${UPDATE_SCRIPT_PATH}" "${SSH_USER}@${SSH_HOST}:/tmp/update.sh.new"
          # 設定執行權限
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" "chmod +x /tmp/deploy.sh.new /tmp/update.sh.new || true"

      - name: Remote deploy with checksum decision
        shell: bash
        run: |
          set -euo pipefail
          ssh -p "${SSH_PORT}" "${SSH_USER}@${SSH_HOST}" bash -lc "
            set -euo pipefail

            # 若遠端沒有 deploy.sh，視為首次部署：移入新檔並執行 deploy.sh
            if [ ! -f ~/deploy.sh ]; then
              echo 'No existing deploy.sh found. First-time deploy.'
              mv /tmp/deploy.sh.new ~/deploy.sh
              chmod +x ~/deploy.sh
              mv /tmp/update.sh.new ~/update.sh
              chmod +x ~/update.sh
              echo 'Running deploy.sh (first-time)...'
              ~/deploy.sh
              exit 0
            fi

            # 有舊 deploy.sh：計算舊檔與新檔的 checksum
            OLD_SUM=\$(sha256sum ~/deploy.sh | awk '{print \$1}')
            NEW_SUM=\$(sha256sum /tmp/deploy.sh.new | awk '{print \$1}')

            echo \"Existing deploy.sh checksum: \$OLD_SUM\"
            echo \"New deploy.sh checksum:      \$NEW_SUM\"

            # 無論如何，先把 update.sh 更新為新版
            mv /tmp/update.sh.new ~/update.sh
            chmod +x ~/update.sh

            if [ \"\$OLD_SUM\" = \"\$NEW_SUM\" ]; then
              echo 'deploy.sh unchanged. Running update.sh...'
              # 仍確保 deploy.sh 可執行
              chmod +x ~/deploy.sh
              ~/update.sh
            else
              echo 'deploy.sh changed. Replacing and running deploy.sh...'
              mv /tmp/deploy.sh.new ~/deploy.sh
              chmod +x ~/deploy.sh
              ~/deploy.sh
            fi
          "
