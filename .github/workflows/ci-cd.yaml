name: CI-CD

# 觸發條件：任何分支 push 都會跑 build；只有 main 會跑 deploy
on:
  push: # 不指定 branches 表示匹配所有分支

jobs:
  # 1) 建置與檢查（所有分支都會執行）
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout # 取得程式碼
        uses: actions/checkout@v5 # https://github.com/actions/checkout

      - name: Install Bun # 安裝 Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install Package # 安裝套件
        run: bun install

      - name: Copy .env.example files # 尋找專案內所有名為 .env.example 的檔案，並複製成對應的 .env
        shell: bash
        run: find . -type f -name ".env.example" -exec sh -c 'cp "$1" "${1%.*}"' _ {} \;

      - name: Lint # 程式碼檢查（Lint）
        run: bun lint

      - name: 建置（Build）
        run: bun run build

  # 2) 部署（僅 main 分支觸發；需 build 成功）
  deploy:
    if: github.ref == 'refs/heads/main' # 只在 main 分支部署
    needs: build
    runs-on: ubuntu-latest

    env:
      SSH_USER: ${{ vars.VAR_SSH_USER }} # 例如 root
      SSH_PORT: ${{ vars.VAR_SSH_PORT }} # 例如 22
      SSH_HOST: ${{ secrets.SSH_HOST }} # IP/域名放在 Secrets
      DEPLOY_SCRIPT_PATH: ./deploy.sh # repo 內 deploy.sh 路徑（預設根目錄）
      UPDATE_SCRIPT_PATH: ./update.sh # repo 內 update.sh 路徑（預設根目錄）

    steps:
      - name: Checkout repo (to get deploy.sh and update.sh of this commit)
        uses: actions/checkout@v5

      - name: Install expect (for SSH passphrase handling)
        shell: bash
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y expect

      - name: Prepare SSH key (with passphrase via agent)
        shell: bash
        env:
          SSH_KEY_PASSPHRASE: ${{ secrets.SSH_KEY_PASSPHRASE }}
        run: |
          set -euo pipefail

          # 創建 .ssh 目錄
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # 寫入 SSH 私鑰文件
          echo "Writing SSH private key to ~/.ssh/id_deploy_enc..."
          KEY_FILE=~/.ssh/id_deploy_enc
          # 將私鑰寫入文件（使用環境變數避免 heredoc 格式問題）
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > "$KEY_FILE"
          chmod 600 "$KEY_FILE"

          # 驗證文件是否成功創建
          if [ ! -f "$KEY_FILE" ]; then
            echo "Error: SSH key file was not created at $KEY_FILE"
            exit 1
          fi

          # 檢查文件大小（不應該為空）
          FILE_SIZE=$(stat -f%z "$KEY_FILE" 2>/dev/null || stat -c%s "$KEY_FILE" 2>/dev/null || echo "0")
          if [ "$FILE_SIZE" -eq 0 ]; then
            echo "Error: SSH key file is empty. Check if SSH_PRIVATE_KEY secret is set correctly."
            exit 1
          fi

          echo "SSH key file created successfully (size: $FILE_SIZE bytes)"

          # 綁定 host 指紋
          echo "Scanning SSH host key..."
          ssh-keyscan -p "${SSH_PORT}" -H "${SSH_HOST}" >> ~/.ssh/known_hosts 2>&1 || true
          chmod 644 ~/.ssh/known_hosts

          # 啟動 ssh-agent 並保存環境變數到文件，以便後續步驟使用
          echo "Starting ssh-agent..."
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=${SSH_AUTH_SOCK}" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=${SSH_AGENT_PID}" >> $GITHUB_ENV
          echo "SSH key file path: $KEY_FILE"

          # 驗證文件路徑（使用絕對路徑）
          ABS_KEY_FILE=$(realpath "$KEY_FILE" || echo "$HOME/.ssh/id_deploy_enc")
          echo "Absolute key file path: $ABS_KEY_FILE"

          # 使用 expect 腳本來處理 passphrase
          echo "Adding SSH key to agent using expect..."
          expect <<EXPECTEOF
            set timeout 10
            set passphrase "$SSH_KEY_PASSPHRASE"
            set key_file "$ABS_KEY_FILE"
            
            # 驗證文件存在
            if {![file exists \$key_file]} {
              puts "Error: Key file does not exist: \$key_file"
              exit 1
            }
            
            spawn ssh-add "\$key_file"
            expect {
              "Enter passphrase" {
                send "\$passphrase\r"
                exp_continue
              }
              "Identity added" {
                puts "Key added successfully"
              }
              "Bad passphrase" {
                puts "Error: Bad passphrase"
                exit 1
              }
              "Could not open a connection" {
                puts "Error: Could not connect to ssh-agent"
                exit 1
              }
              "No such file or directory" {
                puts "Error: Key file not found: \$key_file"
                exit 1
              }
              timeout {
                puts "Error: Timeout waiting for passphrase prompt"
                exit 1
              }
              eof
            }
            catch wait result
            set exit_code [lindex \$result 3]
            if {\$exit_code != 0} {
              puts "Error: ssh-add exited with code \$exit_code"
              exit \$exit_code
            }
          EXPECTEOF

          # 驗證密鑰是否已載入
          echo "Checking loaded SSH keys:"
          if ssh-add -l >/dev/null 2>&1; then
            echo "✓ SSH key successfully loaded into agent"
            ssh-add -l
          else
            echo "✗ No keys loaded in agent - authentication may fail"
            echo "This usually means the passphrase was incorrect or the key format is invalid"
            exit 1
          fi

      - name: Validate local scripts exist
        shell: bash
        run: |
          set -euo pipefail
          [ -f "${DEPLOY_SCRIPT_PATH}" ] || { echo "deploy.sh not found at ${DEPLOY_SCRIPT_PATH}"; exit 1; }
          [ -f "${UPDATE_SCRIPT_PATH}" ] || { echo "update.sh not found at ${UPDATE_SCRIPT_PATH}"; exit 1; }

      - name: Upload scripts to remote (staging paths)
        shell: bash
        run: |
          set -euo pipefail

          # 確保 ssh-agent 環境變數已設置
          if [ -n "${SSH_AUTH_SOCK:-}" ]; then
            export SSH_AUTH_SOCK
          fi
          if [ -n "${SSH_AGENT_PID:-}" ]; then
            export SSH_AGENT_PID
          fi

          # 驗證 ssh-agent 中有密鑰
          if ! ssh-add -l >/dev/null 2>&1; then
            echo "Error: No SSH keys loaded in agent. Previous step must have failed."
            exit 1
          fi

          # 使用 ssh-agent 中的密鑰（不需要 -i 選項）
          SSH_OPTS=(-p "${SSH_PORT}" -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -o IdentitiesOnly=yes)

          echo "Uploading scripts to remote server..."
          # 上傳到遠端暫存路徑，避免直接覆蓋舊檔造成中斷
          scp "${SSH_OPTS[@]}" "${DEPLOY_SCRIPT_PATH}" "${SSH_USER}@${SSH_HOST}:/tmp/deploy.sh.new"
          scp "${SSH_OPTS[@]}" "${UPDATE_SCRIPT_PATH}" "${SSH_USER}@${SSH_HOST}:/tmp/update.sh.new"
          # 設定執行權限
          ssh "${SSH_OPTS[@]}" "${SSH_USER}@${SSH_HOST}" "chmod +x /tmp/deploy.sh.new /tmp/update.sh.new || true"

      - name: Remote deploy with checksum decision
        shell: bash
        run: |
          set -euo pipefail

          # 確保 ssh-agent 環境變數已設置
          if [ -n "${SSH_AUTH_SOCK:-}" ]; then
            export SSH_AUTH_SOCK
          fi
          if [ -n "${SSH_AGENT_PID:-}" ]; then
            export SSH_AGENT_PID
          fi

          # 驗證 ssh-agent 中有密鑰
          if ! ssh-add -l >/dev/null 2>&1; then
            echo "Error: No SSH keys loaded in agent. Previous step must have failed."
            exit 1
          fi

          # 使用 ssh-agent 中的密鑰
          SSH_OPTS=(-p "${SSH_PORT}" -o StrictHostKeyChecking=no -o UserKnownHostsFile=~/.ssh/known_hosts -o IdentitiesOnly=yes)

          ssh "${SSH_OPTS[@]}" "${SSH_USER}@${SSH_HOST}" bash -lc "
            set -euo pipefail

            # 若遠端沒有 deploy.sh，視為首次部署：移入新檔並執行 deploy.sh
            if [ ! -f ~/deploy.sh ]; then
              echo 'No existing deploy.sh found. First-time deploy.'
              mv /tmp/deploy.sh.new ~/deploy.sh
              chmod +x ~/deploy.sh
              mv /tmp/update.sh.new ~/update.sh
              chmod +x ~/update.sh
              echo 'Running deploy.sh (first-time)...'
              ~/deploy.sh
              exit 0
            fi

            # 有舊 deploy.sh：計算舊檔與新檔的 checksum
            OLD_SUM=\$(sha256sum ~/deploy.sh | awk '{print \$1}')
            NEW_SUM=\$(sha256sum /tmp/deploy.sh.new | awk '{print \$1}')

            echo \"Existing deploy.sh checksum: \$OLD_SUM\"
            echo \"New deploy.sh checksum:      \$NEW_SUM\"

            # 無論如何，先把 update.sh 更新為新版
            mv /tmp/update.sh.new ~/update.sh
            chmod +x ~/update.sh

            if [ \"\$OLD_SUM\" = \"\$NEW_SUM\" ]; then
              echo 'deploy.sh unchanged. Running update.sh...'
              # 仍確保 deploy.sh 可執行
              chmod +x ~/deploy.sh
              ~/update.sh
            else
              echo 'deploy.sh changed. Replacing and running deploy.sh...'
              mv /tmp/deploy.sh.new ~/deploy.sh
              chmod +x ~/deploy.sh
              ~/deploy.sh
            fi
          "
